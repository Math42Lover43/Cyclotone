<!DOCTYPE html>
<html>
<head>
<title>Cyclotone</title>
<meta charset="utf-8">
<style>
body,input,button { font-family: 'Roboto', 'Arial', sans-serif }
</style>
<body id="body">
<noscript>
	Warning: The calculator will not work with JavaScript disabled.
</noscript>
Factorize 10<sup><input type="number" id="config_exp" value="5"/></sup> - 1
<button onclick="fullfactorize(document.getElementById("config_exp").value);">Factorize</button>
<div id="factorization">
</div>
<script>
	var ints = [];
	var fullints = [];
	var factorizing = false;
	var status = null;
	function sqrt(value) {
    if (value < 0n) {
        throw 'Square root of negative numbers is not supported';
    }
    if (value < 2n) {
        return value;
    }

    function newtonIteration(n, x0) {
        const x1 = ((n / x0) + x0) >> 1n;
        if (x0 === x1 || x0 === (x1 - 1n)) {
            return x0;
        }
        return newtonIteration(n, x1);
    }

    return newtonIteration(value, 1n);
}
	function add(x,y) {
		return (BigInt(x) + BigInt(y));
	}
	function subt(x,y) {
		return (BigInt(x) - BigInt(y))
	}
	function mult(x,y) {
		return (BigInt(x) * BigInt(y))
	}
	function div(x,y) {
		if(y == "0") {
			return BigInt(x)
		}
		else {
			return (BigInt(x) / BigInt(y))
		}
	}
	function mod(x,y) {
		return BigInt(x) % BigInt(y);
	}
	function power(x,y) {
		return (BigInt(x) ** BigInt(y))
	}
	function lt(x,y) {
		return (BigInt(x) < BigInt(y));
	}
	function polysubst(n,t) {
		var poly = "0";
		var k = "0"
		while(lt(k,n.length.toString())) {
			poly = add(poly,mult(n[k.toString()],power(t,k)));
			k = add(k,"1");
		}
		return poly;
	}
	function factor(x) {
		var factorlist = [];
		var i = BigInt(1);
		while(i <= BigInt(x)) {
			if(BigInt(x) % i == BigInt(0) && !factorlist.includes(BigInt(i))) {
				factorlist.push(BigInt(i));
				
			}
			i += BigInt(1);
		}
		return factorlist;
	}
	function cyclotomics(x) {
		ints.push({"num":div("9","1"),"periods":[div("1","1")]});
		if (x != "1") {
			ints.push({"num":div(power("10",x),"9"),"periods":factor(x.toString())});
		}
	}
	function updatemidfactor(k,t) {
		var roots = [BigInt(ints[BigInt(ints.length) - k])];
		var n = BigInt(0);
		var bypassparam = BigInt(ints[BigInt(ints.length) - k]);
		while(n < BigInt(roots[0].toString().length)) {
			roots.push(roots[roots.length - 1] / BigInt(2) / t * t + BigInt(1));
			roots[roots.length - 2] = roots[roots.length - 2].toString();
			n += BigInt(1);
		}
		roots[roots.length - 1] = roots[roots.length - 1].toString();
		return roots;
	}
	function factor_out(int,frommid) {
		if(BigInt(ints[ints.length - 1]) == BigInt(ints[ints.length - 1]) / (BigInt(int) + BigInt(BigInt(int) == BigInt(0))) * BigInt(int) && int > BigInt(0)) { 
			ints[ints.length - 1] = BigInt((BigInt(ints[ints.length - 1]) / int)).toString();
			ints.unshift(int.toString());
			if(frommid = true) {
				lastmidmanip = true;
			}
		}
	}
	function isPrime(num) {
    if (BigInt(num) <= 1n) { return false; } // 1 is not prime
    for (let i = 2n; i * i <= num; i++) {
        if (BigInt(num) % i === 0n) { return false; }
    }
    return true;
}
	function divan(array,number) {
		var arr = [];
		if(typeof array == "bigint") { return array / number; }
		for(let n = 0n; n < array.length; n++) {
			arr.push(BigInt(array[n]) / BigInt(number));
		}
		return arr;
	}
	function cyclotomic(x) {
		var cycl;
		var structure;
		if (BigInt(x) % 2n == 0n) {
			structure = [BigInt(x) / 2n];
		} else {
			structure = [BigInt(x)];
		}
		for (let n = 3n; n <= BigInt(x); n++) {
			if(BigInt(x) % n == 0n && isPrime(n)) {
				var oldlength = structure.length;
				for (let i = 0n; i < oldlength; i++) {
					structure.push(structure[i] / n);
				}
			}
		}
		for (let n = 0n; n < structure.length; n++) {
			if (BigInt(x) % 2n == 0n) {
				structure[n] = 10n ** BigInt(structure[n]) + 1n;
			} else {
				structure[n] = 10n ** BigInt(structure[n]) - 1n;
			}
		}
		while(structure.length > 1) {
			for (let n = 0n; n < structure.length; n++) {
				if (n % 2n == 0n) {
					if(BigInt(structure.length) - n > 1n) {
						structure[n] = structure[n] / BigInt(structure[n + 1n]);
					}
				} else {
					structure[n] = null;
				}
			}
			structure = structure.filter((number) => number != null);
		}
		return structure[0];
	}
	function factorize(x,y) {
		var limit = BigInt(x) * BigInt(2);
		ints = [y.toString()];
		var xx = BigInt(1);
		var n = BigInt(0); // subtraction from mid
		var lastmidmanip = false;
		var newprimes = false;
		var last = BigInt(1);
		var linear = BigInt(0); // mid number
		var midtrialfactor = updatemidfactor(last,BigInt(x));
		while(midtrialfactor.length < x) {
			midtrialfactor.push(subt(power("10",x.toString()),"1"));
		}
		while(xx < limit) { // By period
			midtrialfactor = updatemidfactor(last,BigInt(x));
			factor_out(BigInt(BigInt(x) * xx * (BigInt(1) + BigInt(x) % BigInt(2)) + BigInt(1)),false);
			linear = BigInt(0); // linears
			while(linear < BigInt(midtrialfactor.length) && !(BigInt(midtrialfactor[linear]) - n ** xx).toString() == "0") {
				factor_out(BigInt(midtrialfactor[linear]) - n ** xx * (BigInt(1) + BigInt(x) % BigInt(2)),true);
				linear += BigInt(1);
			}
			xx += BigInt(1);
			n += BigInt(1);
			if(lastmidmanip) {
				n = BigInt(0);
				lastmidmanip = false;
			}
		}
	}
	function ord(int) {
		if (int.toString()[int.toString().length - 2] == "1") {
			return "th";
		}
		else if (int.toString()[int.toString().length - 1] == "1") {
			return "st";
		}
		else if (int.toString()[int.toString().length - 1] == "2") {
			return "nd";
		}
		else if (int.toString()[int.toString().length - 1] == "3") {
			return "rd";
		}
		else {
			return "th";
		}
	}
	function alfa(n) {
		return (cyclotomic(n) - 1n) / BigInt(n);
	}
	function updatestatus() {
		document.getElementById("factorization").innerHTML = fullints[0].number;
		for(let j = 1n; j < fullints.length; j++) {
			document.getElementById("factorization").innerHTML += " Ã— " + fullints[j].number;
		}
		document.getElementById("factorization").innerHTML += "<br/><br/>" + status;
	}
	function realwork() {
		setInterval(() => {
			if(factorizing) { updatestatus(); }
		}, 1000)
	}
	var cpolynomial;
	var graphx;
	var archives;
	function fullfactorize(x) {
		cpolynomial = 1;
		graphx = 0;
		factorizing = true;
		realwork();
		console.log("Factorizing 10^" + x.toString() + " - 1:")
		fullints = [];
		ints = [];
		var periods = factor(x); console.log("periods: " + periods);
		fullints.push({"number":3n,"period_cov":1n,"prime":true}); fullints.push({"number":3n,"period_cov":1n,"prime":true});
		for(let n = 1n; n < periods.length; n++) {
			fullints.push({"number":cyclotomic(periods[n]),"period_cov":periods[n],"prime":false}); console.log("fullints[" + fullints.length - 1 + "]: " + fullints[fullints.length - 1].number);
		}
		archives = fullints;
		for(let c = 2; c < periods.length; c++) {
			graphx = 1n;
			while(graphx <= 100n) {
				graphx += 1n;
				status = "Factoring " + archives[cpolynomial].period_cov + ord(archives[cpolynomial].period_cov) + " cyclotomic polynomial using modular arithmetic";
				if((alfa(archives[cpolynomial].period_cov) - graphx) % (archives[cpolynomial].period_cov * graphx + 1n) == 0n) {
					console.log((alfa(archives[cpolynomial].period_cov) - graphx) / (archives[cpolynomial].period_cov * graphx + 1n) * BigInt(archives[cpolynomial].period_cov) + 1n);
				}
			}
			cpolynomial += 1;
		}
	}
	fullfactorize(5);
</script>
</body>
</head>
</html>
